# Altinn 3

![](images/altinn_logo.png){style="max-width: 50%; float: right;" fig-alt="Dapla logo"}

Frem mot 2026 skal alle skjema-unders칮kelser i SSB som gjennomf칮res p친 **Altinn 2** flyttes over til [Altinn 3](https://docs.altinn.studio/nb/community/about/). Skjemaer som flyttes til Altinn 3 vil motta sine data p친 **Dapla**, og ikke p친 *bakken* som tidligere. Datafangsten h친ndteres av [Team SUV](https://statistics-norway.atlassian.net/wiki/spaces/CUL/pages/2805530625/Teamsider), mens statistikkseksjonene henter sine data fra Team SUV sitt lagringsomr친de p친 Dapla. I dette kapitlet beskriver vi n칝rmere hvordan statistikkseksjonene kan jobbe med Altinn3-data p친 Dapla. Kort oppsummert best친r det av disse stegene:

1. Statistikkprodusenten avtaler med Team SUV og skjematuviklerne om overf칮ring av skjema fra **Altinn 2** til **Altinn 3**. 
2. N친r statistikkprodusentene f친r beskjed om at Altinn3-skjemaet skal sendes ut til oppgavegiverne, s친 m친 de opprette et [Dapla-team](./opprette-dapla-team.html).
3. N친r Dapla-teamet er opprettet, s친 ber de Team SUV om 친 gi statistikkteamet tilgang til dataene som har kommet inn fra Altinn 3. I tillegg ber de om at Team SUV gir tilgang til teamets *Transfer Service* instans. ^[Forslag til e-post til Team SUV etter at teamet er opprettet:  
*Vi har opprettet et Dapla-tema som heter \<ditt teamnavn\> for 친 jobbe med skjema \<RA-XXXX\>. Kan dere gi oss tilgang til riktig lagringsomr친de og ogs친 gi v친r Transfer Service lesetilgang.*] 
4. Statistikkprodusenten setter opp en automatisk overf칮ring av skjemadata med [Transfer Service](./overf%C3%B8ring-av-data.qmd), fra Team SUV sitt lagringsomr친de over til Dapla-teamet sin kildeb칮tte.
5.  Statistikkprodusentene kan begynne 친 jobbe med dataene i Dapla. Blant annet tilbyr Dapla en **automatiseringstjeneste** man kan bruke for 친 prosessere dataene fra kildedata til inndata^[En typisk prosessering som de fleste vil 칮nske 친 gj칮re er 친 konvertere fra xml-formatet det kom p친, og over til parquet-formatet.].

Under forklarer vi mer med mer detaljer hvordan man g친r frem for gjennomf칮re steg 4-5 over. 

## Forberedelse

N친r skjema-dataene kommer inn fra Altinn 3 til Team SUV sitt lagringsomr친de, s친 er det en del ting som er verdt 친 tenke p친:

- **Hvordan er filene organisert hos Team SUV?**  
Filstrukturen der Team SUV lagrer dataene som kommer inn fra Altinn 3, har en klar struktur. Du kan selv g친 inn 친 kikke p친 dataene, enten [fra Jupyter](./jobbe-med-data.html) eller [Google Cloud Console](./gcc.html), og bli bedre kjent med strukturen^[Du kan g친 inn i [Google Cloud Console](./gcc.html) og s칮ke opp prosjektet til Team SUV som de bruker for 친 dele data. Det heter **altinn-data-prod**, og du finner b칮ttene ved 친 klikke deg inn p친 **Cloud Storage**]. @fig-altinn-path viser en hvordan en typisk filsti ser ut p친 lagringsomr친det til Team SUV. Det starter med navnet til b칮tta som Team SUV har opprettet for skjemaet. Deretter viser den innvitteringsdato, deretter et teknisk navn, og til slutt selve skjemanavnet. 

![Typisk filsti for et Altinn3-skjema.](images/altinn_filsti.png){fig-alt="Bilde av en typisk filsti som forklarer hva de ulike komponentene av stien betyr" #fig-altinn-path}

- **Hvordan organisere dataene i din kildeb칮tte?**  
N친r vi bruker Transfer Service til 친 synkronisere innholdet i Team SUV sitt lagringsomr친de til Dapla-teamet sitt lagringsomr친de, s친 er det mest hensiktmessig 친 fortsette 친 bruke mapppe-strukturen som Team SUV har. Grunnen er at vi ikke kan legge p친 noe logikk som lager en ny struktur. Tjenesten bare kopierer over data. Men du kan kan lage et nytt toppniv친-mappe som du 칮nsker at dataene skal synkroniseres til. F.eks. at alle Altinn-dataene legger seg inn i en mappe som heter `altinn`. Det er spesielt nyttig hvis du har flere datakilder som skal ligge i samme kildeb칮tte.

- **Unike skjemanavn**  
Skjemanavnet du ser i @fig-altinn-path er unike. Dvs. at hvis en oppgavegiver sender inn flere skjemaer p친 samme dag, s친 er fortsatt skjemanavnet unikt. Det er viktig 친 v칝re klar over n친r man bruker [automatiseringstjenesten for kildedata](./automatisering.html) senere. Siden tjenesten trigges per fil, og man er avhengig av unike navn for 친 ikke skrive over filer, s친 er det nyttig 친 vite at man kan videref칮re skjemanavnet i overgangen fra kildedata til inndata. 

## Transfer Service

[Transfer Service](./overf%C3%B8ring-av-data.html) er en tjeneste som kan brukes til 친 synkronisere innholdet mellom b칮tter p친 Dapla, samt mellom bakke og sky. N친r du skal ta i bruk tjenesten for 친 overf칮re data mellom en b칮tte fra Team SUV sitt prosjekt **altinn-data-prod**, til en kildedata-b칮tte i Dapla-teamet ditt, s친 gj칮r du f칮lgende: 

1. F칮lg denne beskrivelsen hvordan man [setter opp overf칮ringsjobber](./overf%C3%B8ring-av-data.html#sette-opp-overf%C3%B8ringsjobber).
2. Etter at du har trykket p친 `Create Transfer Job` velger du **Google Cloud Storage** p친 begge alternativene under **Get Started**. Deretter g친r du videre ved 친 klikke p친 **Next Step**.
3. Under **Choose a source** s친 skal du velge hvor du skal kopiere data fra. Trykk p친 **Browse**. I vinduet som dukker opp trykker du p친 游댵-ikonet ved siden av **Project ID**. I s칮kevinduet som dukker opp s칮ker du opp **altinn-data-prod** og trykker p친 navnet. Da f친r du listet opp alle b칮ttene i altinn-data-prod prosjektet. Til slutt trykker du p친 b칮tta som Team SUV har opprettet for unders칮kelsen^[B칮ttenavnet starter alltid med RA-nummeret til unders칮kelsen.] og klikker **Select** til nederst p친 siden. Trykk deretter **Next step** for 친 g친 videre. 
4. Under **Choose a destination** s친 skal du velge hvor du skal kopiere data til. Dette steget er ganske likt som forrige, men du skal n친 velge ditt eget projekt og kildeb칮tta der. Trykk p친 **Browse**. I vinduet som dukker opp trykker du p친 游댵-ikonet ved siden av **Project ID**. I s칮kevinduet som dukker opp s칮ker du opp **prod-\<ditt teamnavn\>** og trykker p친 navnet. Da f친r du listet opp alle b칮ttene i ditt team sitt prosjekt. Velg kildeb칮tta som har navnet **ssb-prod-\<teamnavn\>-data-kilde**. Hvis du 칮nsker 친 kopiere data til en undermappe i b칮tta, s친 trykker du p친 <span style="color:red;">**>**</span>-ikonet ved b칮ttenavnet og velger 칮nsket undermappe^[Alternativt oppretter du en mappe direkte vinduet ved 친 trykke p친 mappe-ikonet med en **+**-tegn i seg.]. Til slutt trykker du p친 **Select** til nederst p친 siden. Trykk deretter **Next step** for 친 g친 videre.
5. Under **Choose how and when to run job** velger du **Run with custom frequency** og **Starting now** i **Batch**-modus. Hvis du 칮nsker 친 overf칮re s친 ofte som mulig, s친 velger du **Custom frequency** og **Repeat every 1 Hours**. Til slutt trykker du **Next Step** nederst p친 siden.
6. Under **Choose Settings** s친 legger du til en kort beskrivelse av jobben du har opprettet. Under de andre valgene kan du gj칮re f칮lgende: 
    - Under **Advanced transfer Options** trenger du ikke gj칮re noen endringer. 
    - Under **When to overwrite** kan du velge **If different**.
    - Under **When to delete** kan du velge **Never**.
    - Under **Manifest** trenger du ikke huke av. 
    - Under **Logging options** velger du samme som vist i @fig-ts-log.

![Valg av opsjoner for logging i Transfer Service](images/transfer-service-logging.png){fig-alt="Bilde av en typisk filsti som forklarer hva de ulike komponentene av stien betyr" #fig-ts-log}

Til slutt trykker du **Create** for 친 aktivere tjenesten. Den vil da sjekke Team SUV sin b칮tte hver time og kopiere over alle filer som ikke allerede eksisterer statistikkteamets kildeb칮tte. 

## Automatiseringstjeneste for kildedata

N친r du har satt opp Transfer Service til 친 kopiere over filer fra Team SUV sin b칮tte til statistikkteamets kildeb칮tte, s친 vil det potensielt komme inn nye skjemaer hver time. Disse kan du lese inn i **Jupyter** og jobbe med hvis du er kildedata-ansvarlig i teamet. Hvis du ikke er det s친 m친 du vente til dataene er tilgjengeliggjort i produkt-b칮tta til teamet. 

Siden f친 personer innehar rollen som kildedata-ansvarlig s친 er det laget en automatiseringstjeneste som kan bearbeide alle filer som kommer inn i kildeb칮tta. Den lar deg kj칮re et python-script p친 alle filer som kommer inn i kildeb칮tta. 

[Les mer om hvordan du kan bruker tjenesten her.](./automatisering.html)

## Tips og triks

I denne delen deles noen tips og triks for 친 jobbe med Altinn3-dataene p친 Dapla. Fokuset vil v칝re p친 hvordan du kan lese inn og transformere xml-filer fra skjema-dataene.

### Liste ut innhold i en mappe

For 친 se innholdet i en mappe gir det mest mening 친 bruke [Google Cloud Console](./gcc.html). Her kan du se b친de filer og mapper i et pek-og-klikk grensesnitt. Men du kan ikke se p친 innholdet i filene der. Til det m친 du bruke Jupyter.

Anta at vi 칮nsker 친 liste alle som leverte skjema den **10. mars 2023**. Da kan vi bruke [gcsfs](https://gcsfs.readthedocs.io/en/latest/api.html) til 친 gj칮re det^[For 친 autentisere seg mot GCS kan vi bruke **AuthClient** fra **dapla-toolbelt**.]: 

```python
from dapla import FileClient

fs = FileClient.get_gcs_file_system()

file_path = "gs://ra0678-01-altinn-data-prod-e17d-ssb-altinn/2023/3/10"

xml_files = []
for root, dirs, files in fs.walk(file_path):
    for file in files:
        if file.endswith(".xml"):
            xml_files.append(f"{root}/{file}")

# Print the list of parquet files
xml_files

```

Her bruker vi `fs.walk()`-funksjonen fra **gcsfs** til 친 loope gjennom alle undermapper av `file_path`, og legge alle filer som slutter med `.xml` til listen `xml_files`. Dermed har vi et Python-objekt som kun brukes til 친 hente inn de filene vi 칮nsker. Vi bruker da det vi vet om mappestrukturen i Team SUV sin b칮tte som vi s친 tidligere i @fig-altinn-path. 

### Printe XML i Jupyter

Noen ganger kan det v칝re nyttig 친 se en xml-fil direkte. Da kan vi lese den inn i Jupyter og printe den ut. Her er et eksempel p친 hvordan vi kan gj칮re det, samtidig som vi formatterer den med `xml.dom.minidom`:

```python

import xml.dom.minidom

from dapla import FileClient
from IPython.display import Markdown, display

file_path = "gs://ra0678-01-altinn-data-prod-e17d-ssb-altinn/2023/3/24/28c34dce4232_e7bed8a4-def5-42dc-b1e2-b9fc66beb769/form_28c34dce4232.xml"


def print_file():
    fs = FileClient.get_gcs_file_system()
    with fs.open(file_path, mode="r") as f:
        single_xml = f.read()
    dom_tree = xml.dom.minidom.parseString(single_xml)
    pretty_xml_data = dom_tree.toprettyxml()
    display(Markdown("```xml\n{}\n```".format(pretty_xml_data)))

```	

### Fra XML til Pandas DataFrame

De f칝rreste 칮nsker 친 jobbe direkte med XML-filer. Derfor er det nyttig 친 kunne transformere XML-filene til et mer brukervennlig format, f.eks. en **Pandas Dataframe**. Her er et eksempel p친 hvordan vi kan gj칮re det med Pandas:

```python

import xml.etree.ElementTree as ET
import pandas as pd
from dapla import FileClient

def single_xml_to_dataframe(file_path: str) -> pd.DataFrame:
    fs = FileClient.get_gcs_file_system()

    with fs.open(file_path, mode="r") as f:
        single_xml = f.read()

    root = ET.fromstring(single_xml)
    intern_info = root.find("InternInfo")
    kontakt = root.find("Kontakt")
    skjemadata = root.find("Skjemadata")

    data = []
    all_tags = set()

    for element in intern_info:
        all_tags.add(element.tag)

    for element in kontakt:
        all_tags.add(element.tag)

    for element in skjemadata:
        all_tags.add(element.tag)

    for tag in all_tags:
        element = intern_info.find(tag)
        if element is None:
            element = kontakt.find(tag)
        if element is None:
            element = skjemadata.find(tag)
        if element is not None:
            value = element.text
            data.append(value)
        else:
            data.append(None)

    # Include the full path to the XML file in the data list
    data.append(file_path)

    # Create the DataFrame inside the function
    df = pd.DataFrame([data], columns=list(all_tags) + ["pathToXmlFile"])
    path_to_xml_file_split = df["pathToXmlFile"].str.split("/")
    return df

# Run the function
file_path = "gs://ra0678-01-altinn-data-prod-e17d-ssb-altinn/2023/3/24/28c34dce4232_e7bed8a4-def5-42dc-b1e2-b9fc66beb769/form_28c34dce4232.xml"
df = single_xml_to_dataframe(file_path=file_path)

```

I funksjonen s친 s칮ker vi etter alle elementer under taggene `intern_info`, `kontakt` og `skjemadata`. Dvs. at vi lager en dataframe med en rad, der vi tar med all data fra xml-filen. Til slutt legger vi til en kolonne med filstien til filen. Det kan v칝re nyttig senere hvis man g친 tilbake til xml-filen for 친 sjekke om konverteringen til en dataframe er riktig. 

Funksjonen `single_xml_to_dataframe()` kan brukes til 친 loope over en liste med filstier (vi viste hvordan man lager en slik liste tidligere i kapitlet). Men et typisk problem som vil oppst친 da er at xml-filene har forskjellig antall elementer i seg, som gir dataframes med ulikt antall kolonner, og derfor vil ikke Pandas vite hvordan man konkatinerer disse. For 친 fikse dette m친 du modifisere funksjonen til 친 ta h칮yde for dette. 



