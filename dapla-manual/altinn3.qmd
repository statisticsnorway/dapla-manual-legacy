# Altinn 3

![](images/altinn_logo.png){style="max-width: 50%; float: right;" fig-alt="Dapla logo"}

Frem mot sommeren 2025 skal alle skjema-unders칮kelser i SSB som gjennomf칮res p친 **Altinn 2** flyttes over til [Altinn 3](https://docs.altinn.studio/nb/community/about/). Skjemaer som flyttes til Altinn 3 vil motta sine data p친 **Dapla**, og ikke p친 *bakken* som tidligere. Datafangsten h친ndteres av [Team SUV](https://statistics-norway.atlassian.net/wiki/spaces/CUL/pages/2805530625/Teamsider), mens statistikkseksjonene henter sine data fra Team SUV sitt lagringsomr친de p친 Dapla. I dette kapitlet beskriver vi n칝rmere hvordan statistikkseksjonene kan jobbe med Altinn3-data p친 Dapla. Kort oppsummert best친r det av disse stegene:

1. Statistikkprodusenten avtaler overf칮ring av skjema fra **Altinn 2** til **Altinn 3** med planleggere p친 S821, som koordinerer denne jobben. 
2. N친r statistikkprodusentene f친r beskjed om at Altinn3-skjemaet skal sendes ut til oppgavegiverne, s친 m친 de opprette et [Dapla-team](./opprette-dapla-team.html).
3. N친r Dapla-teamet er opprettet, og f칮rste skjema er sendt inn, s친 ber de Team SUV om 친 gi statistikkteamet tilgang til dataene som har kommet inn fra Altinn 3. I tillegg ber de om at Team SUV gir tilgang til teamets *Transfer Service* instans. ^[Forslag til e-post til Team SUV etter at teamet er opprettet:  
*Vi har opprettet et Dapla-tema som heter \<ditt teamnavn\> for 친 jobbe med skjema \<RA-XXXX\>. Kan dere gi oss tilgang til riktig lagringsomr친de og ogs친 gi v친r Transfer Service lesetilgang.*] Merk at det m친 gis separate tilganger for data i staging- og produksjonsmilj칮. 
4. Statistikkprodusenten setter opp en automatisk overf칮ring av skjemadata med [Transfer Service](./overf%C3%B8ring-av-data.qmd), fra Team SUV sitt lagringsomr친de over til Dapla-teamet sin kildeb칮tte.
5.  Statistikkprodusentene kan begynne 친 jobbe med dataene i Dapla. Blant annet tilbyr Dapla en **automatiseringstjeneste** man kan bruke for 친 prosessere dataene fra kildedata til inndata^[En typisk prosessering som de fleste vil 칮nske 친 gj칮re er 친 konvertere fra xml-formatet det kom p친, og over til parquet-formatet.].

Under forklarer vi mer med mer detaljer hvordan man g친r frem for gjennomf칮re steg 4-5 over. 

::: {.callout-warning}
## Ansvar for kildedata

Selv om Team SUV tar ansvaret for datafangst fra Altinn3, s친 er det statistikkteamet som har ansvaret for langtidslagring av dataene i sin kildeb칮tte. Det vil si at at statistikkteamet m친 s칮rge for at data overf칮res til sin kildeb칮tte, og at de kan ikke regne med at Team SUV tar vare p친 en backup av dataene. 
:::

## Forberedelse

N친r skjema-dataene kommer inn fra Altinn 3 til Team SUV sitt lagringsomr친de, s친 er det en del ting som er verdt 친 tenke p친:

- **Hvordan er filene organisert hos Team SUV?**  
Filstrukturen der Team SUV lagrer dataene som kommer inn fra Altinn 3, har en klar struktur. Du kan selv g친 inn 친 kikke p친 dataene, enten [fra Jupyter](./jobbe-med-data.html) eller [Google Cloud Console](./gcc.html), og bli bedre kjent med strukturen^[Du kan g친 inn i [Google Cloud Console](./gcc.html) og s칮ke opp prosjektet til Team SUV som de bruker for 친 dele data. Det heter **altinn-data-prod**, og du finner b칮ttene ved 친 klikke deg inn p친 **Cloud Storage**]. @fig-altinn-path viser en hvordan en typisk filsti ser ut p친 lagringsomr친det til Team SUV. Det starter med navnet til b칮tta som Team SUV har opprettet for skjemaet. Deretter viser den innvitteringsdato, deretter et teknisk navn, og til slutt selve skjemanavnet. 

![Typisk filsti for et Altinn3-skjema.](images/altinn_filsti.png){fig-alt="Bilde av en typisk filsti som forklarer hva de ulike komponentene av stien betyr" #fig-altinn-path}

- **Hvordan organisere dataene i din kildeb칮tte?**  
N친r vi bruker Transfer Service til 친 synkronisere innholdet i Team SUV sitt lagringsomr친de til Dapla-teamet sitt lagringsomr친de, s친 er det mest hensiktmessig 친 fortsette 친 bruke mapppe-strukturen som Team SUV har. Grunnen er at vi ikke kan legge p친 noe logikk som lager en ny struktur. Tjenesten bare kopierer over data. Men du kan kan lage et nytt toppniv친-mappe som du 칮nsker at dataene skal synkroniseres til. F.eks. at alle Altinn-dataene legger seg inn i en mappe som heter `altinn`. Det er spesielt nyttig hvis du har flere datakilder som skal ligge i samme kildeb칮tte.

- **Unike skjemanavn**  
Skjemanavnet du ser i @fig-altinn-path er unike. Dvs. at hvis en oppgavegiver sender inn flere skjemaer p친 samme dag, s친 er fortsatt skjemanavnet unikt. Det er viktig 친 v칝re klar over n친r man bruker [automatiseringstjenesten for kildedata](./automatisering.html) senere. Siden tjenesten trigges per fil, og man er avhengig av unike navn for 친 ikke skrive over filer, s친 er det nyttig 친 vite at man kan videref칮re skjemanavnet i overgangen fra kildedata til inndata. 

## Transfer Service

N친r vi skal overf칮re filer fra Team SUV sin b칮tte til v친r kildeb칮tte, s친 kan vi gj칮re det manuelt fra Jupyter [som forklart her.](./altinn3.qmd#kopiere-filer-manuelt). Men det er en bedre l칮sning 친 bruke en tjeneste som gj칮r dette for deg. [Transfer Service](./overf%C3%B8ring-av-data.html) er en tjeneste som kan brukes til 친 synkronisere innholdet mellom b칮tter p친 Dapla, samt mellom bakke og sky. N친r du skal ta i bruk tjenesten for 친 overf칮re data mellom en b칮tte fra Team SUV sitt prosjekt **altinn-data-prod**, til en kildedata-b칮tte i Dapla-teamet ditt, s친 gj칮r du f칮lgende: 

1. F칮lg denne beskrivelsen hvordan man [setter opp overf칮ringsjobber](./overf%C3%B8ring-av-data.html#sette-opp-overf%C3%B8ringsjobber).
2. Etter at du har trykket p친 `Create Transfer Job` velger du **Google Cloud Storage** p친 begge alternativene under **Get Started**. Deretter g친r du videre ved 친 klikke p친 **Next Step**.
3. Under **Choose a source** s친 skal du velge hvor du skal kopiere data fra. Trykk p친 **Browse**. I vinduet som dukker opp trykker du p친 游댵-ikonet ved siden av **Project ID**. I s칮kevinduet som dukker opp s칮ker du opp **altinn-data-prod** og trykker p친 navnet. Da f친r du listet opp alle b칮ttene i altinn-data-prod prosjektet. Til slutt trykker du p친 b칮tta som Team SUV har opprettet for unders칮kelsen^[B칮ttenavnet starter alltid med RA-nummeret til unders칮kelsen.] og klikker **Select** til nederst p친 siden. Trykk deretter **Next step** for 친 g친 videre. 
4. Under **Choose a destination** s친 skal du velge hvor du skal kopiere data til. Dette steget er ganske likt som forrige, men du skal n친 velge ditt eget projekt og kildeb칮tta der. Trykk p친 **Browse**. I vinduet som dukker opp trykker du p친 游댵-ikonet ved siden av **Project ID**. I s칮kevinduet som dukker opp s칮ker du opp **prod-\<ditt teamnavn\>** og trykker p친 navnet. Da f친r du listet opp alle b칮ttene i ditt team sitt prosjekt. Velg kildeb칮tta som har navnet **ssb-prod-\<teamnavn\>-data-kilde**. Hvis du 칮nsker 친 kopiere data til en undermappe i b칮tta, s친 trykker du p친 <span style="color:red;">**>**</span>-ikonet ved b칮ttenavnet og velger 칮nsket undermappe^[Alternativt oppretter du en mappe direkte vinduet ved 친 trykke p친 mappe-ikonet med en **+**-tegn i seg.]. Til slutt trykker du p친 **Select** til nederst p친 siden. Trykk deretter **Next step** for 친 g친 videre.
5. Under **Choose how and when to run job** velger du **Run with custom frequency** og **Starting now** i **Batch**-modus. Hvis du 칮nsker 친 overf칮re s친 ofte som mulig, s친 velger du **Custom frequency** og **Repeat every 1 Hours**. Til slutt trykker du **Next Step** nederst p친 siden.
6. Under **Choose Settings** s친 legger du til en kort beskrivelse av jobben du har opprettet. Under de andre valgene kan du gj칮re f칮lgende: 
    - Under **Advanced transfer Options** trenger du ikke gj칮re noen endringer. 
    - Under **When to overwrite** kan du velge **If different**.
    - Under **When to delete** kan du velge **Never**.
    - Under **Manifest** trenger du ikke huke av. 
    - Under **Logging options** velger du samme som vist i @fig-ts-log.

![Valg av opsjoner for logging i Transfer Service](images/transfer-service-logging.png){fig-alt="Bilde av en typisk filsti som forklarer hva de ulike komponentene av stien betyr" #fig-ts-log}

Til slutt trykker du **Create** for 친 aktivere tjenesten. Den vil da sjekke Team SUV sin b칮tte hver time og kopiere over alle filer som ikke allerede eksisterer statistikkteamets kildeb칮tte. 

## Automatiseringstjeneste for kildedata

N친r du har satt opp Transfer Service til 친 kopiere over filer fra Team SUV sin b칮tte til statistikkteamets kildeb칮tte, s친 vil det potensielt komme inn nye skjemaer hver time. Disse kan du lese inn i **Jupyter** og jobbe med hvis du er kildedata-ansvarlig i teamet. Hvis du ikke er det s친 m친 du vente til dataene er tilgjengeliggjort i produkt-b칮tta til teamet. 

Siden f친 personer innehar rollen som kildedata-ansvarlig s친 er det laget en automatiseringstjeneste som kan bearbeide alle filer som kommer inn i kildeb칮tta. Den lar deg kj칮re et python-script p친 alle filer som kommer inn i kildeb칮tta. 

[Les mer om hvordan du kan bruker tjenesten her.](./automatisering.html)

## Tips og triks

I denne delen deles noen tips og triks for 친 jobbe med Altinn3-dataene p친 Dapla. Fokuset vil v칝re p친 hvordan du kan lese inn og transformere xml-filer fra skjema-dataene.

### Liste ut innhold i en mappe

For 친 se innholdet i en mappe gir det mest mening 친 bruke [Google Cloud Console](./gcc.html). Her kan du se b친de filer og mapper i et pek-og-klikk grensesnitt. Men du kan ikke se p친 innholdet i filene der. Til det m친 du bruke Jupyter.

Anta at vi 칮nsker 친 liste ut alle som leverte skjema den **10. mars 2023**. Da kan vi bruke [gcsfs](https://gcsfs.readthedocs.io/en/latest/api.html) til 친 gj칮re det^[For 친 jobbe mot datat i GCS som i et "vanlig" filsysten kan vi bruke **FileClient.get_gcs_file_system()** fra **dapla-toolbelt**.]: 

```python
from dapla import FileClient

fs = FileClient.get_gcs_file_system()

# Henter ut alle xml-filer under en filsti
xml_files = fs.glob("gs://ra0678-01-altinn-data-prod-e17d-ssb-altinn/2023/3/10/**.xml")

# Print the list of parquet files
xml_files

```

Her bruker vi `fs.glob()`-funksjonen fra **gcsfs** til 친 loope gjennom alle undermapper av `gs://ra0678-01-altinn-data-prod-e17d-ssb-altinn/2023/3/10/`, og legge alle filer som slutter med `.xml` til listen `xml_files`. Dermed har vi et Python-objekt som kun brukes til 친 hente inn de filene vi 칮nsker. Vi bruker da det vi vet om mappestrukturen i Team SUV sin b칮tte som vi s친 tidligere i @fig-altinn-path. 

### Printe XML i Jupyter

Noen ganger kan det v칝re nyttig 친 se en xml-fil direkte. Da kan vi lese den inn i Jupyter og printe den ut. Her er et eksempel p친 hvordan vi kan gj칮re det, samtidig som vi formatterer den med `xml.dom.minidom`:

```python
from xml.dom.minidom import parseString

from dapla import FileClient

# Kobler oss p친 b칮ttene
fs = FileClient.get_gcs_file_system()

# Sett inn filstien din her
file = "gs://ssb-prod-dapla-felles-data-delt/altinn3/form_dc551844cd74.xml"

dom = parseString(fs.cat_file(file))
pretty_xml = dom.toprettyxml(indent="  ")
print(pretty_xml)

```	
Vi brukte da `fs.cat_file()` til 친 hente inn innholdet i mappen, gjorde det om til xml-object, og formatterer outputen med `xml.dom.minidom`. Resultatet vil da se ut noe s친nt som dette:

```xml
<?xml version="1.0" ?>
<melding xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" dataFormatProvider="SERES" dataFormatId="7079" dataFormatVersion="47315">
  <InternInfo>
    <raNummer>RA-XXXX</raNummer>
    <skjemaVersjon>1.0</skjemaVersjon>
    <undersoekelsesNr>XXXXX</undersoekelsesNr>
    <visOppgaveByrde>0</visOppgaveByrde>
    <visBrukeropplevelse>0</visBrukeropplevelse>
    <delregNr>2XXXXX</delregNr>
    <periodeFritekst>3. kvartal 2022</periodeFritekst>
    <periodeFomDato>2022-07-01</periodeFomDato>
    <periodeTomDato>2022-09-30</periodeTomDato>
    <periodeType>KVRT</periodeType>
    <periodeNummer>3</periodeNummer>
    <periodeAAr>2022</periodeAAr>
    <periodeDato> </periodeDato>
    <enhetsIdent>XXXXXX</enhetsIdent>
    <enhetsType>BEDR</enhetsType>
    <enhetsOrgNr>XXXXXXXXX</enhetsOrgNr>
    <enhetsNavn>STATISTISK SENTRALBYR칀 </enhetsNavn>
    <enhetsGateadresse>Akersveien 26</enhetsGateadresse>
    <enhetsPostnr>0177</enhetsPostnr>
    <enhetsPoststed>OSLO</enhetsPoststed>
    <enhetsAvdeling>AVD XXXX</enhetsAvdeling>
    <reporteeOrgNr>XXXXXXXXX</reporteeOrgNr>
  </InternInfo>
  <Kontakt>
    <kontaktPersonNavn>OLA NORDMANN</kontaktPersonNavn>
    <kontaktPersonEpost>ola@tull.no</kontaktPersonEpost>
    <kontaktPersonTelefon> </kontaktPersonTelefon>
    <kontaktInfoBekreftet>1</kontaktInfoBekreftet>
    <kontaktInfoKommentar>Dette er en et eksempel for Dapla-manualen</kontaktInfoKommentar>
  </Kontakt>
  <Skjemadata>
    <ledigeStillinger>75</ledigeStillinger>
    <datoPrefill> </datoPrefill>
  </Skjemadata>
</melding>
```	


### Fra XML til Pandas DataFrame

De f칝rreste 칮nsker 친 jobbe direkte med XML-filer. Derfor er det nyttig 친 kunne transformere XML-filene til et mer brukervennlig format, f.eks. en **Pandas Dataframe**. Her er et eksempel p친 hvordan vi kan gj칮re det med Pandas:

```python

import xml.etree.ElementTree as ET
import pandas as pd
from dapla import FileClient

def single_xml_to_dataframe(file_path: str) -> pd.DataFrame:
    fs = FileClient.get_gcs_file_system()

    with fs.open(file_path, mode="r") as f:
        single_xml = f.read()

    root = ET.fromstring(single_xml)
    intern_info = root.find("InternInfo")
    kontakt = root.find("Kontakt")
    skjemadata = root.find("Skjemadata")

    data = []
    all_tags = set()

    for element in intern_info:
        all_tags.add(element.tag)

    for element in kontakt:
        all_tags.add(element.tag)

    for element in skjemadata:
        all_tags.add(element.tag)

    for tag in all_tags:
        element = intern_info.find(tag)
        if element is None:
            element = kontakt.find(tag)
        if element is None:
            element = skjemadata.find(tag)
        if element is not None:
            value = element.text
            data.append(value)
        else:
            data.append(None)

    # Include the full path to the XML file in the data list
    data.append(file_path)

    # Create the DataFrame inside the function
    df = pd.DataFrame([data], columns=list(all_tags) + ["pathToXmlFile"])
    path_to_xml_file_split = df["pathToXmlFile"].str.split("/")
    return df

# Run the function
file_path = "gs://ra0678-01-altinn-data-prod-e17d-ssb-altinn/2023/3/24/28c34dce4232_e7bed8a4-def5-42dc-b1e2-b9fc66beb769/form_28c34dce4232.xml"
df = single_xml_to_dataframe(file_path=file_path)

```

I funksjonen s친 s칮ker vi etter alle elementer under taggene `intern_info`, `kontakt` og `skjemadata`. Dvs. at vi lager en dataframe med en rad, der vi tar med all data fra xml-filen. Til slutt legger vi til en kolonne med filstien til filen. Det kan v칝re nyttig senere hvis man g친 tilbake til xml-filen for 친 sjekke om konverteringen til en dataframe er riktig. 

Funksjonen `single_xml_to_dataframe()` kan brukes til 친 loope over en liste med filstier (vi viste hvordan man lager en slik liste tidligere i kapitlet). Men et typisk problem som vil oppst친 da er at xml-filene har forskjellig antall elementer i seg, som gir dataframes med ulikt antall kolonner, og derfor vil ikke Pandas vite hvordan man konkatinerer disse. For 친 fikse dette m친 du modifisere funksjonen til 친 ta h칮yde for dette.

### Kopiere filer manuelt



Hvis vi 칮nsker 친 kopiere filer manuelt (dvs. ikke med Transfer Service) fra Team SUV sine b칮tter til egen kildeb칮tte, kan vi gj칮re det fra Jupyter. Vi har tidligere sett hvordan vi kan [kopiere enkeltfiler](./jobbe-med-data.html#kopiere-filer) mellom to b칮tter. Under viser vi hvordan man kan kopiere alle filer under en viss filsti med kommandoen `fs.copy()`:

```python	
from dapla import FileClient

# Setter opp en filsystem-instans mot GCS
fs = FileClient.get_gcs_file_system()

from_path = "gs://ssb-prod-arbmark-skjema-data-kilde/ledstill/altinn/2022/11/21/"
to_path = "gs://ssb-prod-dapla-felles-data-delt/altinn3/"
fs.copy(from_path, to_path, recursive=True)

```

I koden over s친 kopierer vi alle filer under `from_path` til `to_path`. Vi bruker `recursive=True` for 친 s칮rge for at vi kopierer alle filer under `from_path`.

I eksempelet over s친 kopierer vi over alt som er `from_path` og dets undermapper. I tilfellet med Altinn-data s친 ligger det ogs친 pdf-filer av skjemaet som kanskje ikke 칮nsker 친 kopiere. I de tilfellene kan vi f칮rst s칮ke etter de filene vi 칮nsker 친 kopiere og legge de i en liste. Deretter kan vi kopiere over en og en fil fra listen. Denne tiln칝rmingen er veldig nyttig hvis vi 칮nsker 친 filtrere ut filer som ikke er XML-filer, eller vi 칮nsker en annen mappestruktur en den som ligger i `from_path`. Her er en m친te vi kan gj칮re det p친:

```python
from dapla import FileClient

# Lager en filsystem-instans av GCS
fs = FileClient.get_gcs_file_system()

# Henter ut alle xml-filer under en filsti
xml_files = fs.glob("gs://ra0678-01-altinn-data-prod-e17d-ssb-altinn/2023/3/10/**.xml")

# Stien du 칮nsker 친 kopiere til.
# Koden under foutsetter at du har med gs:// f칮rst
to_folder = "gs://ssb-prod-dapla-felles-data-delt/"

# Kopierer over filene
for file in xml_files:
    from_bucket = file.split("/")[0]
    to_bucket = to_folder.split("/")[2]
    to_path = file.replace(
        from_bucket, to_bucket
    )
    fs.cp(file, to_path)

```

I koden over s친 bruker vi `fs.glob()` og `**` til 친 s칮ke rekursivt etter alle xml-filer under filstien `gs://ra0678-01-altinn-data-prod-e17d-ssb-altinn/2023/3/10`. Deretter kopierer vi over filene til egen kildeb칮tte med `fs.cp()`. N친r vi skal kopiere over til en ny b칮tte m친 vi bestemme oss for hvor filene skal ligge og hvor mye av den gamle filstien vi skal beholde. Anta at vi skal beholde hele mappestrukturen i Team SUV sin b칮tte. Da kan vi egentlig bare erstatte `ra0678-01-altinn-data-prod-e17d-ssb-altinn/` med den nye b칮tte-navnet, og vi vil f친 den samme strukturen som i Team SUV sin b칮tte.



